import json
from typing import List

import botocore.client
import botocore.exceptions

import dstack._internal.server.utils.cloudinit as cloudinit
import dstack.version as version


def get_image_id(ec2_client: botocore.client.BaseClient, cuda: bool) -> str:
    image_name = (
        f"dstack-{version.base_image}" if not cuda else f"dstack-cuda-{version.base_image}"
    )

    response = ec2_client.describe_images(Filters=[{"Name": "name", "Values": [image_name]}])
    images = sorted(
        (i for i in response["Images"] if i["State"] == "available"),
        key=lambda i: i["CreationDate"],
        reverse=True,
    )
    if not images:
        raise RuntimeError(f"Image {image_name} not found")  # TODO custom error
    return images[0]["ImageId"]


def create_role_and_policy(iam_client: botocore.client.BaseClient, project_id: str) -> str:
    policy_name = "dstack_policy_" + project_id.replace("-", "_").lower()
    role_name = "dstack_role_" + project_id.replace("-", "_").lower()

    try:
        iam_client.get_role(RoleName=role_name)
        return role_name
    except botocore.exceptions.ClientError as e:
        if e.response["Error"]["Code"] != "NoSuchEntity":
            raise e

    response = iam_client.create_policy(
        PolicyName=policy_name,
        Description="Generated by dstack",
        PolicyDocument=json.dumps(
            {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Action": "ec2:*",
                        "Resource": "*",
                        "Condition": {
                            "StringEquals": {
                                "aws:ResourceTag/dstack_project": project_id,
                            }
                        },
                    },
                ],
            }
        ),
        Tags=[
            {"Key": "owner", "Value": "dstack"},
            {"Key": "dstack_project", "Value": project_id},
        ],
    )
    policy_arn = response["Policy"]["Arn"]
    iam_client.create_role(
        RoleName=role_name,
        AssumeRolePolicyDocument=json.dumps(
            {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Action": "sts:AssumeRole",
                        "Effect": "Allow",
                        "Principal": {"Service": "ec2.amazonaws.com"},
                    }
                ],
            }
        ),
        Description="Generated by dstack",
        MaxSessionDuration=3600,
        Tags=[
            {"Key": "owner", "Value": "dstack"},
            {"Key": "dstack_project", "Value": project_id},
        ],
    )
    iam_client.attach_role_policy(RoleName=role_name, PolicyArn=policy_arn)
    return role_name


def create_iam_instance_profile(iam_client: botocore.client.BaseClient, project_id: str) -> str:
    role_name = create_role_and_policy(iam_client, project_id)

    try:
        response = iam_client.get_instance_profile(InstanceProfileName=role_name)
        return response["InstanceProfile"]["Arn"]
    except botocore.exceptions.ClientError as e:
        if e.response["Error"]["Code"] != "NoSuchEntity":
            raise e

    response = iam_client.create_instance_profile(
        InstanceProfileName=role_name,
        Tags=[
            {"Key": "owner", "Value": "dstack"},
            {"Key": "dstack_project", "Value": project_id},
        ],
    )
    instance_profile_arn = response["InstanceProfile"]["Arn"]
    iam_client.add_role_to_instance_profile(
        InstanceProfileName=role_name,
        RoleName=role_name,
    )
    return instance_profile_arn


def create_security_group(ec2_client: botocore.client.BaseClient, project_id: str) -> str:
    security_group_name = "dstack_security_group_" + project_id.replace("-", "_").lower()

    response = ec2_client.describe_security_groups(
        Filters=[
            {
                "Name": "group-name",
                "Values": [security_group_name],
            },
        ],
    )
    if response.get("SecurityGroups"):
        return response["SecurityGroups"][0]["GroupId"]

    security_group = ec2_client.create_security_group(
        Description="Generated by dstack",
        GroupName=security_group_name,
        TagSpecifications=[
            {
                "ResourceType": "security-group",
                "Tags": [
                    {"Key": "owner", "Value": "dstack"},
                    {"Key": "dstack_project", "Value": project_id},
                ],
            },
        ],
    )
    group_id = security_group["GroupId"]

    ec2_client.authorize_security_group_ingress(
        GroupId=group_id,
        IpPermissions=[
            {
                "FromPort": 22,
                "ToPort": 22,
                "IpProtocol": "tcp",
                "IpRanges": [{"CidrIp": "0.0.0.0/0"}],
            }
        ],
    )

    ec2_client.authorize_security_group_egress(
        GroupId=group_id,
        IpPermissions=[{"IpProtocol": "-1"}],
    )
    return group_id


def get_spot_options(spot: bool) -> dict:
    if not spot:
        return {}
    return {
        "InstanceMarketOptions": {
            "MarketType": "spot",
            "SpotOptions": {
                "SpotInstanceType": "one-time",
                "InstanceInterruptionBehavior": "terminate",
            },
        },
    }


def get_user_data(image_name: str, authorized_keys: List[str]) -> str:
    build = cloudinit.get_dstack_runner_version()
    env = {
        "DSTACK_BACKEND": "aws",
        "DSTACK_RUNNER_LOG_LEVEL": "6",
        "DSTACK_RUNNER_VERSION": build,
        "DSTACK_IMAGE_NAME": image_name,
        "DSTACK_PUBLIC_SSH_KEY": "\n".join(authorized_keys),
        "DSTACK_HOME": "/root/.dstack",
    }
    script = cloudinit.get_dstack_shim(build)
    for k, v in env.items():
        script += [f'export "{k}={v}"']
    script += ["nohup dstack-shim --dev docker --keep-container >/root/shim.log 2>&1 &"]
    return cloudinit.get_cloud_config([["sh", "-c", " && ".join(script)]], authorized_keys)
